#!/usr/bin/env python3

## projection of the diet problem

import sys
import os
import math
import numpy as np
import scipy
#from blis.py import einsum, gemv, gemm
from math import sqrt
#from scipy.sparse import dok_matrix
from amplpy import AMPL, DataFrame
import time
import bz2

myZero = 1e-10
projdat = "projdiet.dat"
jllC = 1.0
ampldatatransfer = "file"
#ampldatatransfer = "process" ## *much slower* than out to file and read

#################### FUNCTIONS #####################

# generate a componentwise Normal(0,1) matrix
def normalmatrix(m, n):
    return np.random.normal([0],[[1]],(m,n))

# generate a componentwise Uniform(0,1) matrix
def uniformmatrix(m, n):
    return np.random.rand(m,n)

### generate a samples from an Achlioptas distribution
def achlioptas_sample(p=1.0/6.0):
    ret = 0
    uniformsample = np.random.uniform(0,1)
    if uniformsample < p:
        ret = -1
    elif uniformsample > 1-p:
        ret = 1
    else:
        ret = 0
    return ret
    
### generate an Achlioptas m x n random projection matrix
def achlioptas(m, n, p=1.0/6.0):
    A = np.zeros((m,n))
    for i in range(m):
        for j in range(n):
            aij = achlioptas_sample(p)
            if aij != 0:
                A[i,j] = aij
    return A

## read diet problem data file written in AMPL .dat format
def readDat(filename):
    readparam = "[None]"
    m = 0
    n = 0
    c = {}
    b = {}
    A = {}
    with bz2.open(filename, "rt") as f:
        for line in f:
            # look at file line by line
            line = line.strip()
            if len(line) == 0:
                continue
            if line[0] == '#':
                continue
            L = line.split()
            if L[0] == "param":
                readparam = L[1]
                if readparam == "m":
                    m = int(L[3][0:-1])
                elif readparam == "n":
                    n = int(L[3][0:-1])
                continue
            elif L[0] == ';':
                readparam = "[None]"
                continue
            elif readparam == "c":
                j = int(L[0])
                cj = float(L[1])
                c[j] = cj
            elif readparam == "b":
                i = int(L[0])
                bi = float(L[1])
                b[i] = bi
            elif readparam == "A":
                i = int(L[0])
                j = int(L[1])
                Aij = float(L[2])
                A[(i,j)] = Aij
    return (m,n,A,b,c)


####################### MAIN #######################

## read command line
if len(sys.argv) < 3:
    print("syntax: " + sys.argv[0] + " file.dat jlleps")
    exit(1)

t0 = time.time()
print("reading data")
(m,n,Ad,bd,cd) = readDat(sys.argv[1])
jlleps = float(sys.argv[2])

## form LP data in vector/matrix form
c = np.zeros(n)
for j in cd:
    c[j-1] = cd[j]
b = np.zeros(m)
for i in bd:
    b[i-1] = bd[i]
A = np.zeros((m,n))
for (i,j) in Ad:
    A[i-1,j-1] = Ad[(i,j)]

# A needs to be padded with an identity for Phase I (before projection)
Im = np.eye(m)
AI = np.hstack((A,Im))
t1 = time.time()
cpuread = t1-t0
print("   data read in {0:.2f}s".format(cpuread))

## random projector
t2 = time.time()
print(jllC, jlleps, n, m)
k = int(round(jllC*(1/jlleps**2)*math.log(n + m))) #+m due to I_m padding 
print("projecting from " + str(m) + " to " + str(k) + " constraints")
T = (1/sqrt(k))*normalmatrix(k,m)
#T = (sqrt(sqrt(m))/sqrt(k))*achlioptas(k,m,1/sqrt(m)) ## slower (!!)
# try:
#     TA = gemm(T,AI)  ## slower than np.dot (!!)
# except:
#     print("using np.dot")
#     TA = np.dot(T,AI)
TA = np.dot(T,AI)
Tb = np.dot(T,b)
t3 = time.time()
cpuproj = t3-t2
print("   projection took {0:.2f}s".format(cpuproj))

## print projected data to projdat
if ampldatatransfer == "file":
    print("writing projected problem to projdiet.dat")
    t4 = time.time()
    if os.path.exists(projdat):
        os.remove(projdat)
    f = open(projdat, "w")
    print("# projdiet.dat generated by projdiet.py", file=f)
    print("param m := " + str(k) + ";", file=f)
    print("param n := " + str(n) + ";", file=f)
    print("param c :=", file=f)
    jcd = sorted(zip(cd.keys(), cd.values()))
    for (j,cval) in jcd:
        print("  " + str(j) + "  " + "{:.3f}".format(cval), file=f)
    print(";", file=f)
    print("param b :=", file=f)
    for i in range(k):
        if abs(Tb[i]) > myZero:
            print("  " + str(i+1) + "  " + "{:.12f}".format(Tb[i]), file=f)
    print(";", file=f)
    print("param A :=", file=f)
    for i in range(k):
        for j in range(n):
            if abs(TA[i,j]) > myZero:
                print("  " + str(i+1) + " " + str(j+1) + "  " + "{:.12f}".format(TA[i,j]), file=f)
    print(";", file=f)
    f.close()
    t5 = time.time()
    cpuout = t5-t4
    print("   wrote instance in {0:.2f}s".format(cpuout))
elif ampldatatransfer == "process":
    cpuout = 0

## read projected problem with AMPL
print("passing data to AMPL using", ampldatatransfer)
diet = AMPL()
ta0 = time.time()
if ampldatatransfer == "file":    
    diet.read("diet.mod")
    diet.readData(projdat)
elif ampldatatransfer == "process":
    diet.read("projdiet.mod")
    dfN = DataFrame('N')
    setN = list(range(1,n+1)) ## AMPL counting starts from 1
    dfN.setColumn('N', setN)
    dfN.addColumn('c', c)
    diet.setData(dfN, 'N')
    dfM = DataFrame('M')
    setM = list(range(1,k+1)) ## AMPL counting starts from 1
    dfM.setColumn('M', setM)
    dfM.addColumn('b', Tb)
    diet.setData(dfM, 'M')
    dfA = DataFrame(('M', 'N'), 'A')
    Adict = {(ntr,fd):TA[i,j] for i,ntr in enumerate(setM) for j,fd in enumerate(setN)}
    dfA.setValues(Adict)
    diet.setData(dfA)
ta1 = time.time()
cpuampl = ta1-ta0
print("   passed data to AMPL in {0:.2f}s".format(ta1-ta0))

## solve the problem with AMPL
print("solving projected problem")
t6 = time.time()
diet.setOption("solver", "cplex")
#diet.setOption("cplex_options", 'display=1')
diet.setOption("cplex_options", 'baropt bardisplay=1')
diet.setOption("presolve", "0")
diet.solve()
solveres = diet.getData("solve_result")
solve_result = solveres.getRowByIndex(0)[0]
objfun = diet.getObjective("cost")
cost = objfun.value()
xvar = diet.getVariable("x")
x = np.zeros(n)
xstatus = {}
xbasis = []
for j in range(n):
    x[j] = xvar[j+1].value()
    xstatus[j] = xvar[j+1].sstatus()
    if xstatus[j] == "bas":
        xbasis.append(j)
cstatus = {}
cbasis = []
nutrcon = diet.getConstraint("nutrients")
for i in range(k):
    cstatus[i] = nutrcon[i+1].sstatus()
    if cstatus[i] == "bas":
        cbasis.append(i)        
t7 = time.time()
cpusolve = t7-t6
print("   solved projected problem in {0:.2f}s".format(cpusolve))

## retrieval
print("solution retrieval")
t8 = time.time()
AH = A[:,xbasis]
IH = Im[:,cbasis]
AIH = np.hstack((AH,IH))
AIHpsinv = np.dot(np.linalg.inv(np.dot(AIH.T,AIH)),AIH.T)
xretrcomp = np.dot(AIHpsinv, b)
xretr = np.zeros(n+m)
for i,j in enumerate(xbasis):
    xretr[j] = xretrcomp[i]
offset = len(xbasis)
for i,j in enumerate(cbasis):
    xretr[n+j] = xretrcomp[offset+i]
t9 = time.time()
cpuretr = t9-t8
print("   retrieval took {0:.2f}s".format(cpuretr))

## test feasibility
feasretr = np.linalg.norm(np.subtract(np.dot(AI,xretr),b))
negretr = -sum(min(0,xretr[j]) for j in range(n))
print("x =", end='')
for i,xi in enumerate(xretr):
    if abs(xi) > myZero:
        print(" ({0:d},{1:.3f})".format(i+1,xi), end='')
print()
print("cost =", cost)
print("||(A|I_m)xretr - b||_2 / m =", feasretr / m)
print("||min(xretr,0)||_1 / (n+m) =", negretr / (n+m))
cpu = cpuread+cpuproj+cpuout+cpusolve+cpuretr
print("CPU times: read={0:.2f},proj={1:.2f},out={2:.2f},solve={3:.2f},retr={4:.2f},tot={5:.2f}".format(cpuread,cpuproj,cpuout,cpusolve,cpuretr,cpu))

## remove huge projected file
if os.path.exists(projdat):
    os.remove(projdat)
